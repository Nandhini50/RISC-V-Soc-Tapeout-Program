INTRODUCTION TO IVERILOG DESIGN TEST BENCH
Simulator
       A simulator is a software or hardware tool that imitates the behavior of a real-world system, circuit, or process so you can 
   study, test, or verify it without actually building the physical system.
      Basically here RTL design is checked for its adherence to the spec by simulating the design

Here , IVERILOG is the tool is used as simulator
     
‚ñ∂Ô∏è Running the Simulation

Compile and simulate:

iverilog -o sim/sim.out src/design.v tb/testbench.v
vvp sim/sim.out


View waveform:

gtkwave sim/wave.vcd
 you can view the invoke of iverilog by cloning all the files from git
   week 1/d1 w1.png
GTKWave

GTKWave is a waveform viewer used to visualize signal activity from Verilog/VHDL simulations.
It reads VCD (Value Change Dump), LXT, or FST files generated during simulation.
Helps debug timing, check logic, and verify your DUT (Design Under Test).

for example the GTKWave waveform can be viewed in day1/gtkwave.png

SYNTHESIZER -Yosys

Summary
üñ•Ô∏è What is Yosys?

Yosys (Yosys Open SYnthesis Suite) is an open-source logic synthesizer for Verilog designs.

It takes your HDL code (RTL description) and synthesizes it into a gate-level netlist using a target technology library (like FPGA cells or ASIC standard cells).

Think of it as the step after simulation ‚Üí it converts your design into real hardware representation.

‚ö° Why Do We Need Synthesis?

Simulation (with Icarus Verilog) only checks functionality.

Synthesis (with Yosys) converts your code into something hardware (FPGA/ASIC) can understand.

Output ‚Üí netlist (in formats like BLIF, EDIF, Verilog netlist).

üìÇ Workflow (Simulation vs Synthesis)

Simulation (Icarus Verilog + GTKWave)

Verify logic correctness using testbenches.

Output ‚Üí .vcd waveform.

Synthesis (Yosys)

Convert Verilog RTL ‚Üí gate-level representation.

Output ‚Üí netlist.


lOGIC SYNTHESIS
  Purpose of Different Flavors of Same gate
        Even though the logic function is identical (say, a 2-input AND), the transistor sizing inside the gate can be changed to provide different trade-offs:

            1.Drive strength (output current capacity)

            2.Speed (propagation delay)

            3.Area (number of transistors / layout size)

            4.Power consumption (dynamic + leakage)

                  So you can pick a version of the gate that best fits the timing, area, and power requirements of a specific path in the design.

üîπ 2. Example: AND2 slow / medium / fast

     AND2_X1 (slow, low drive)

    Small transistors ‚Üí smaller area, lower leakage, less dynamic power.

     But slower, can‚Äôt drive heavy loads (large fanout).

     AND2_X2 (medium drive)

     Medium transistor sizing.

     Balanced speed vs area/power.

     AND2_X4 or AND2_X8 (fast, high drive)

     Large transistors ‚Üí faster switching, stronger drive (can drive long wires or many loads).

     But consumes more area and power.

    üëâ Same applies to 3-input versions (AND3, NAND3, OR3, etc.), just with an extra input.

üîπ 3. Why the library provides all these

   Designers (or synthesis tools like Yosys) need flexibility:

   On a critical timing path ‚Üí use a high-drive / fast cell so signals arrive in time.

   On a non-critical path ‚Üí use a slow / low-drive cell to save area and power.

   During timing closure ‚Üí synthesis + place & route tools automatically swap cells (slow ‚Üî fast) until timing constraints are met.

   This process is called cell sizing or gate sizing.

üîπ 4. Analogy

    Think of it like light bulbs:

     A 5W bulb (low drive): small, low power, dimmer (slow).

     A 10W bulb (medium): balanced.

     A 20W bulb (high drive): brighter (fast), but consumes more electricity and is bigger.

     Same ‚Äúfunction‚Äù (lighting), but different strengths depending on what you need.

üîπ 5. Practical Example (Sky130)

     In Sky130 (and other libraries), you‚Äôll see cells like:

     sky130_fd_sc_hd__and2_0 ‚Üí AND2, lowest drive strength.

     sky130_fd_sc_hd__and2_2 ‚Üí AND2, medium drive strength.

     sky130_fd_sc_hd__and2_4 ‚Üí AND2, highest drive strength.

     Here _0, _2, _4 represent different transistor sizings ‚Üí affecting speed, power, area.

Logic synthesis is the crucial step that transforms high-level RTL descriptions written in 
Verilog or SystemVerilog into an optimized gate-level netlist that can be implemented on real
hardware such as FPGAs or ASICs. While simulation ensures that a design behaves correctly at the 
functional level, synthesis makes the design practical by mapping it onto actual technology-specific
building blocks like LUTs, flip-flops, or standard cells. Through optimization techniques and the 
use of different cell flavors with varying drive strengths, synthesis balances performance, power,
and area requirements while meeting timing constraints. It serves as the bridge between design intent 
and physical realization, enabling a smooth transition from abstract logic to manufacturable and testable 
digital circuits. In short, simulation verifies correctness, but synthesis ensures the design can exist as real hardware.
